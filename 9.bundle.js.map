{"version":3,"sources":["webpack:///./src/utils/render.tsx","webpack:///./src/components/Slide/index.tsx","webpack:///./src/components/Slide/useElements.ts","webpack:///./src/components/Slide/useSlideObserve.ts","webpack:///./src/components/Slide/useCodeLineObserve.ts","webpack:///./src/utils/parsePlugins/injectLineNumber.ts"],"names":["render","htmlString","TABLE_TAGS","processingInstructions","shouldProcessNode","parent","type","includes","name","isTableDescendent","processNode","HtmlToReact","ProcessNodeDefinitions","React","processDefaultNode","Parser","lowerCaseTags","lowerCaseAttributeNames","parseWithInstructions","Section","styled","section","Slide","memo","index","ref","useRef","elements","useState","setElements","useEffect","useElements","slideNumber","useSlideObserver","observe","unobserve","current","useSlideObserve","useCodeLineObserver","node","entries","querySelectorAll","forEach","element","dataLine","getAttribute","useCodeLineObserve","className","id"],"mappings":"2OAQA,SAASA,EAAOC,GACd,IAAMC,EAAa,CAAC,QAAS,QAAS,QAAS,MAI/C,IAGMC,EAAyB,CAC7B,CACEC,kBADF,YACsC,IAAhBC,EAAgB,EAAhBA,OAClB,MAAa,SADqB,EAARC,OARhC,SAA2BD,GACzB,OAAOA,GAAUH,EAAWK,SAASF,EAAOG,MAQjBC,CAAkBJ,IAK3CK,YAT2B,IAAIC,IAAYC,uBAAuBC,KAS9BC,qBAOxC,OAJe,IAAIC,SAAO,CACxBC,eAAe,EACfC,yBAAyB,IAEbC,sBACZjB,GAnBkB,kBAAM,IAqBxBE,G,mIC3BJ,IAAMgB,EAAUC,IAAOC,QAAV,KAWPC,EAAQC,gBAAK,YAAkD,IAAjCtB,EAAiC,EAAjCA,WAAYuB,EAAqB,EAArBA,MACxCC,EAAMC,iBAAoB,MAE1BC,ECnBR,SAAqB1B,GAAY,MACG2B,mBAAS,MADZ,WACtBD,EADsB,KACZE,EADY,KAG7B,OADAC,qBAAU,kBAAMD,EAAY7B,EAAOC,MAAc,CAACA,IAC3C0B,EDgBQI,CAAY9B,GAI7B,OEvBF,YAA+C,IAApBwB,EAAoB,EAApBA,IAAKO,EAAe,EAAfA,YAAe,EACZC,cAAvBC,EADmC,EACnCA,QAASC,EAD0B,EAC1BA,UACjBL,qBAAU,WAGN,OAFIL,EAAIW,SACJF,EAAQF,EAAaP,EAAIW,SACtB,kBAAMD,EAAUH,MACxB,CAACP,EAAKO,EAAaE,EAASC,IFcjCE,CAAgB,CAAEZ,MAAKO,YAAaR,EAAQ,IGnB9C,YAA+C,IAAjBG,EAAiB,EAAjBA,SAAUF,EAAO,EAAPA,IAC5BS,EAAYI,cAAZJ,QACRJ,qBAAU,WACN,IAAMS,EAAOd,EAAIW,QACjB,GAAIG,EAAM,CACN,IAAMC,EAAU,IACSD,aAAmC,EAASA,EAAKE,iBAAL,WCGpD,eDFAC,SAAQ,SAACC,GACtB,IAAMC,EAAWD,EAAQE,aCEb,aDDRD,IACAJ,EAAQI,GAAYD,MAE5BT,EAAQM,MAEb,CAACb,EAAUF,EAAKS,IHMrBY,CAAmB,CAAEnB,WAAUF,QAG7B,kBAACN,EAAD,CAASM,IAAKA,EAAKsB,UAAU,QAAQC,GAAE,gBAAWxB,EAAQ,IACvDG","file":"9.bundle.js","sourcesContent":["import React from \"react\";\nimport HtmlToReact, { Parser } from \"html-to-react\";\n\ninterface Node {\n  name: string;\n  attribs: Record<string, string>;\n}\n\nfunction render(htmlString: HtmlString): SlideContentElements {\n  const TABLE_TAGS = [\"table\", \"thead\", \"tbody\", \"tr\"];\n  function isTableDescendent(parent) {\n    return parent && TABLE_TAGS.includes(parent.name);\n  }\n  const isValidNode = () => true;\n\n  const processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions(React);\n  const processingInstructions = [\n    {\n      shouldProcessNode({ parent, type }) {\n        if (type === \"text\" && isTableDescendent(parent)) {\n          return false;\n        }\n        return true;\n      },\n      processNode: processNodeDefinitions.processDefaultNode,\n    },\n  ];\n  const parser = new Parser({\n    lowerCaseTags: false,\n    lowerCaseAttributeNames: false,\n  });\n  return parser.parseWithInstructions(\n    htmlString,\n    isValidNode,\n    processingInstructions\n  );\n}\n\nexport { render };\n","import React, { memo, useRef } from \"react\";\nimport styled from \"styled-components\";\n\nimport { useElements } from \"./useElements\";\nimport { useSlideObserve } from \"./useSlideObserve\";\nimport { useCodeLineObserve } from \"./useCodeLineObserve\";\n\nconst Section = styled.section`\n  svg {\n    background-color: white;\n  }\n`;\n\ninterface SlideProps {\n  htmlString: HtmlString;\n  index: number;\n}\n\nconst Slide = memo(function Slide({ htmlString, index }: SlideProps) {\n  const ref = useRef<HTMLElement>(null);\n\n  const elements = useElements(htmlString);\n  useSlideObserve({ ref, slideNumber: index + 1 });\n  useCodeLineObserve({ elements, ref });\n\n  return (\n    <Section ref={ref} className=\"slide\" id={`slide-${index + 1}`}>\n      {elements}\n    </Section>\n  );\n});\n\nexport { Slide };\n","import { useEffect, useState } from \"react\";\nimport { render } from \"utils/render\";\nfunction useElements(htmlString) {\n    const [elements, setElements] = useState(null);\n    useEffect(() => setElements(render(htmlString)), [htmlString]);\n    return elements;\n}\nexport { useElements };\n","import { useEffect } from \"react\";\nimport { useSlideObserver } from \"contexts/SlideObserver\";\nfunction useSlideObserve({ ref, slideNumber }) {\n    const { observe, unobserve } = useSlideObserver();\n    useEffect(() => {\n        if (ref.current)\n            observe(slideNumber, ref.current);\n        return () => unobserve(slideNumber);\n    }, [ref, slideNumber, observe, unobserve]);\n}\nexport { useSlideObserve };\n","import { useEffect } from \"react\";\nimport { useCodeLineObserver } from \"contexts/CodeLineObserver\";\nimport { CODE_LINE_CLASS_NAME, DATA_LINE_ATTRIBUTE, } from \"utils/parsePlugins/injectLineNumber\";\nfunction useCodeLineObserve({ elements, ref }) {\n    const { observe } = useCodeLineObserver();\n    useEffect(() => {\n        const node = ref.current;\n        if (node) {\n            const entries = {};\n            const codeLineElements = node === null || node === void 0 ? void 0 : node.querySelectorAll(`.${CODE_LINE_CLASS_NAME}`);\n            codeLineElements.forEach((element) => {\n                const dataLine = element.getAttribute(DATA_LINE_ATTRIBUTE);\n                if (dataLine)\n                    entries[dataLine] = element;\n            });\n            observe(entries);\n        }\n    }, [elements, ref, observe]);\n}\nexport { useCodeLineObserve };\n","/* eslint-disable */\nconst RULES = [\n    \"blockquote_open\",\n    \"code_block\",\n    \"fence\",\n    \"heading_open\",\n    \"image\",\n    \"link_open\",\n    \"list_item_open\",\n    \"paragraph_open\",\n    \"table_open\",\n];\nconst CODE_LINE_CLASS_NAME = \"code-line\";\nconst DATA_LINE_ATTRIBUTE = \"data-line\";\nfunction injectLineNumber(md) {\n    const { marpit_inline_svg_open } = md.renderer.rules;\n    // Enables line sync by per slides\n    md.renderer.rules.marpit_inline_svg_open = (tokens, idx, opts, env, self) => {\n        var _a;\n        const slide = tokens\n            .slice(idx + 1)\n            .find((t) => t.type === \"marpit_slide_open\");\n        if ((_a = slide.map) === null || _a === void 0 ? void 0 : _a.length) {\n            tokens[idx].attrJoin(\"className\", CODE_LINE_CLASS_NAME);\n            tokens[idx].attrSet(DATA_LINE_ATTRIBUTE, slide.map[0]);\n        }\n        const renderer = marpit_inline_svg_open || self.renderToken;\n        return renderer.call(self, tokens, idx, opts, env, self);\n    };\n    // Enables line sync per elements\n    RULES.forEach((rule) => {\n        const original = md.renderer.rules[rule];\n        md.renderer.rules[rule] = (tokens, idx, options, env, self) => {\n            var _a;\n            const token = tokens[idx];\n            if ((_a = token.map) === null || _a === void 0 ? void 0 : _a.length) {\n                token.attrJoin(\"className\", CODE_LINE_CLASS_NAME);\n                token.attrSet(DATA_LINE_ATTRIBUTE, token.map[0]);\n            }\n            const renderer = original || self.renderToken;\n            return renderer.call(self, tokens, idx, options, env, self);\n        };\n    });\n}\nexport { CODE_LINE_CLASS_NAME, DATA_LINE_ATTRIBUTE, injectLineNumber };\n"],"sourceRoot":""}